from aiogram import types, Dispatcher
from create_bot import dp
import json
import string

#  # декоратор обозначает событие, когда в наш чат кто-то
# что-то пишет
# async def echo_send(message: types.Message):  # асинхронная функция и сюда
# будут попадать любые текстовые сообщения для бота, которые отправляют
# пользователи в чат
# if message.text == 'Привет':
#     await message.answer('И тебе привет')

# await message.answer(message.text)  # здесь нам необходимо сами

# @dp.message_handler()
async def echo_send(message: types.Message):
    # if {i.lower().translate(str.maketrans('', '', string.punctuation))
    #     for i in message.text.split(' ')}.intersection(set(json.load(open(
    #         'cenz.json')))) != set():
    if {i.lower().translate(str.maketrans('', '', string.punctuation))
        for i in message.text.split()}.intersection(set(json.load(open(
        'cenz.json')))):   # и так тоже работает !!!!!Если  при пересечении
        # двух множеств создается НЕ пустое множество, то у нас автоматически
        # получается значение True,если пустое False
        await message.reply('Маты запрещены')
        await message.delete()

'''у строк есть метод translate ,которой необходимо передать макет изменений 
для замены символов в строке ,где он находится. Значит мы здесь с вами 
обращаемся к объекту типу данных строка и здесь записываем его метод 
maketrans, в которой необходимо передать три аргумента: первый аргумент это 
перечень, что менять записываем пустую строку , второй аргумент -  на что 
менять ,мы его тоже оставляем пустым и теперь здесь третий аргумент, 
указывает какие символы из строки вообще нужно убрать , то есть все знаки 
пунктуации перечислять мы здесь все не будем, мы его возьмем из стандартного 
модуля string, там есть перечень уже готовых знаков пунктуации, 
так и записываем string.punctuation, не забываем теперь , необходимо 
импортировать модуль string, чтобы взять оттуда знаки пунктуации и так 
отлично, почти что фильтр готов и того вот, готовый наш генератор множества. 

 Применяем метод interception(пересечение множеств) и здесь формируем новое 
 множество, 
   как аргумент 
читая данные из нашего джейсон файла записываем set здесь у нас используем 
библиотеку json  метод load , который позволяет прочитать данные из файла, в 
него передаем объект чтения, то есть грубо говоря просто open 
мы с вами читаем файл cenz.json и того, вот эта проверка, если вдруг 
нет совпадений, то есть нет мата, возвращает нам сюда пересечение множеств 
первого нашего, из нашего сообщения и множества из нашего  jason  файла .
   Если там совпадение нет, то  сюда вернется пустое множество, 
поэтому мы здесь записываем не равно, то есть если наше множество не 
пустое, которое сюда попала, то значит кто-то поматерился '''


# отправить ответное сообщение нашим ботом,это можно сделать тремя разными
# способами. await ключевое слово и оно
# относится к асинхронности ,то есть подождать пока не появится в потоке
# свободное место для выполнения этой команды
# await message.reply(message.text)  # когда вы указываете reply ,он будет
# также упоминать сообщение, на которое отвечает. Эти два метода позволяют
# отправить боту сообщение в ответ, куда бы ни написал пользователь, например в
# группу или в личные сообщения .
# await bot.send_message(message.from_user.id, message.text) # третий
# вариант,который позволяет отправить сообщениение посредственно в личку
# пользователю, причем обратите внимание, если пользователь написал
# в какую-либо группу,но не писал ни разу боту, бот первый пользователю
# написать не может, в данном случае будет ошибка.сюда нам необходимо
# записать id пользователя, которому отправить это сообщение и через запятую
# пишем, то что мы хотим отправить ,в данном случае напишем то же самое
# message.text.


# executor.start_polling(dp, skip_updates=True, on_startup=on_startup)  #
# команда
# запуска нашего
# бота, здесь мы передаем наш диспетчер и записываем команду skip_updates и
# здесь устанавливаем значение True.
'''Для чего это необходимо,если здесь не записать вот эту команду,то есть
пропускать обновление то в моменты, когда наш бот не онлайн ему будут приходить
сообщения и когда бот выйдет в онлайн то, тогда его засыпет всеми этими
сообщениями и бот будет на них отвечать. Обычно это не нужно и поэтому здесь
записывается тогда конструкция skip_updates=True, то есть наш бот на
сообщения, которые были ему отправлены, когда он был не онлайн, отвечать
просто  не будет '''

def register_handlers_other(dp: Dispatcher):
    dp.register_message_handler(echo_send)
