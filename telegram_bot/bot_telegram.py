# from aiogram import Bot
# from aiogram.dispatcher import Dispatcher
import aiogram.utils
from create_bot import dp
from data_base import sqlite_db
from data_base import users_db
from aiogram.utils import executor
# from inline import dp
# from Callback_bot import dp

# bot = Bot(token=os.getenv('TOKEN'))# инициализируем нашего бота Метод
# os.getenv() в Python возвращает значение ключа переменной среды, если он
# существует, в противном случае возвращает значение по умолчанию None У
# меня к сожолению,оно не сработало! bot = Bot(
# token='5935424823:AAEQYLYpI-xEF5JqtTgUvC71VUhzu865w3I')
# dp = Dispatcher(bot)  # необходимо инициализировать диспетчер и передать
# экземпляр нашего  бота (bot)
#  Класс диспетчер это непосредственно тот класс, который позволяет
# нашему боту реагировать, то есть он улавливает события в чате или событие
# отправки пользователям сообщения боту и соответствующим образом мы
# прописываем его реакцию


async def on_startup(_):
    print(('Бот вышел в онлаайн'))
    sqlite_db.sql_start()
    users_db.sql_create_user()
    users_db.sql_create_order()


from handlers import client, admin, other


client.register_handlers_client(dp)
admin.register_handlers_admin(dp)
other.register_handlers_other(dp)


executor.start_polling(dp, skip_updates=True, on_startup=on_startup)  #
# команда запуска нашего бота, здесь мы передаем наш диспетчер и записываем
# команду skip_updates и здесь устанавливаем значение True.
'''Для чего это необходимо,если здесь не записать вот эту команду,то есть
пропускать обновление то в моменты, когда наш бот не онлайн ему будут приходить
сообщения и когда бот выйдет в онлайн то, тогда его засыпет всеми этими
сообщениями и бот будет на них отвечать. Обычно это не нужно и поэтому здесь
записывается тогда конструкция skip_updates=True, то есть наш бот на
сообщения, которые были ему отправлены, когда он был не онлайн, отвечать
просто  не будет '''

#  # Пустой декоратор обозначает событие, когда в наш чат кто-то,
# что-то пишет
# @dp.message_handler()
# async def echo_send(message: types.Message):  # асинхронная функция и
# сюда(в скобки(message: types.Message))
# будут попадать любые текстовые сообщения для бота, которые отправляют
# пользователи в чат

'''теперь необходимо отправить ответное сообщение нашим ботом,это можно сделать
# тремя разными способами'''
#    1.await message.answer(message,text)  здесь скобках передаем то,что мы
#     хотим отправить обратно, в данном случае мы из события  message
#     получаем текст
#     2.await message.reply(message,text) # reply будет также упоминать
#     сообщение на которое отвечает
#    3.bot.send_message(message.from_user.id, message.text) это сообщение
#    в личку пользователю. Пользовател написав в какую-либо группу,
#    но не писал ни разу боту, а бот первый
#    пользователю написать не может, в данном случае будет ошибка !!!
#     send_message-он сработает только в том случае, если пользователь
#     уже когда-либо писал боту, ну или первый добавился к нему в контакты.
'''В скобки нам необходимо записать id пользователя, которому отправить это 
сообщение.
  message.from_user.id -- получаем id пользовтеля
  message.text - то что мы хотим отправить в данном случае'''

# if message.text == 'Привет':
#     await message.answer('И тебе привет')

# await message.answer(message.text)  # здесь нам необходимо сами
# @dp.message_handler()
# async def echo_send(message: types.Message):
#     # if {i.lower().translate(str.maketrans('', '', string.punctuation))
#     #     for i in message.text.split(' ')}.intersection(set(json.load(open(
#     #         'cenz.json')))) != set():
#     if {i.lower().translate(str.maketrans('', '', string.punctuation))
#         for i in message.text.split()}.intersection(set(json.load(open(
#         'cenz.json')))):   # и так тоже работает !!!!!Если  при пересечении
#         # двух множеств создается НЕ пустое множество, то у нас автоматически
#         # получается значение True,если пустое False
#         await message.reply('Маты запрещены')
#         await message.delete()

'''у строк есть метод translate ,которой необходимо передать макет изменений 
для замены символов в строке ,где он находится. Значит мы здесь с вами 
обращаемся к объекту типу данных строка и здесь записываем его метод 
maketrans, в которой необходимо передать три аргумента: первый аргумент это 
перечень, что менять записываем пустую строку , второй аргумент -  на что 
менять ,мы его тоже оставляем пустым и теперь здесь третий аргумент, 
указывает какие символы из строки вообще нужно убрать , то есть все знаки 
пунктуации перечислять мы здесь все не будем, мы его возьмем из стандартного 
модуля string, там есть перечень уже готовых знаков пунктуации, 
так и записываем string.punctuation, не забываем теперь , необходимо 
импортировать модуль string, чтобы взять оттуда знаки пунктуации и так 
отлично, почти что фильтр готов и того вот, готовый наш генератор множества. 

 Применяем метод interception(пересечение множеств) и здесь формируем новое 
 множество, 
   как аргумент 
читая данные из нашего джейсон файла записываем set здесь у нас используем 
библиотеку json  метод load , который позволяет прочитать данные из файла, в 
него передаем объект чтения, то есть грубо говоря просто open 
мы с вами читаем файл cenz.json и того, вот эта проверка, если вдруг 
нет совпадений, то есть нет мата, возвращает нам сюда пересечение множеств 
первого нашего, из нашего сообщения и множества из нашего  jason  файла .
   Если там совпадение нет, то  сюда вернется пустое множество, 
поэтому мы здесь записываем не равно, то есть если наше множество не 
пустое, которое сюда попала, то значит кто-то поматерился '''

# отправить ответное сообщение нашим ботом,это можно сделать тремя разными
# способами. await ключевое слово и оно
# относится к асинхронности ,то есть подождать пока не появится в потоке
# свободное место для выполнения этой команды
# await message.reply(message.text)  # когда вы указываете reply ,он будет
# также упоминать сообщение, на которое отвечает. Эти два метода позволяют
# отправить боту сообщение в ответ, куда бы ни написал пользователь, например в
# группу или в личные сообщения .
# await bot.send_message(message.from_user.id, message.text) # третий
# вариант,который позволяет отправить сообщениение посредственно в личку
# пользователю, причем обратите внимание, если пользователь написал
# в какую-либо группу,но не писал ни разу боту, бот первый пользователю
# написать не может, в данном случае будет ошибка.сюда нам необходимо
# записать id пользователя, которому отправить это сообщение и через запятую
# пишем, то что мы хотим отправить ,в данном случае напишем то же самое
# message.text.


# import telebot
#
# token = '5935424823:AAEQYLYpI-xEF5JqtTgUvC71VUhzu865w3I'  # Вставь свой токен
# bot = telebot.TeleBot(token)
#
#
# @bot.message_handler(content_types=["text"])
# def repeat_all_messages(message):
#     bot.send_message(message.chat.id, message.text)
#
#
# if __name__ == '__main__':
#     bot.polling(none_stop=True)
